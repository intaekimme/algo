## 정올 2577 회전초밥 문제

문제에서 구해야 하는 것 : 먹을 수 있는 초밥의 가짓수의 최대값

 입력

접시 수 : N (for문 row 입력 횟수)

초밥 가짓수 : d (출력의 최댓값에 해당)

연속해서 먹는 접시 수 : k (k개를 연속해서 먹을 경우 할인 제공)

쿠폰 번호 c : 쿠폰은 하나만 주어진다.

 

문제 요구사항에서 가격은 가장 적게 쓰면서 먹는 초밥의 가짓수는 많아야 한다 이런 얘기가 없다

그렇다면 연속해서 먹어 할인을 받는 것 보다 띄엄띄엄 먹으면서 종류만 다르게 하면 최대 가짓수를 먹을 수 있다….그런데 생각해 보니까 몇 개를 띄엄띄엄 먹으면 몇 개를 먹어라는 말이 없다.

문제를 풀려면 몇 개를 먹는데 그 때 가능한 최대 가짓수 이렇게 문제가 나와야 한다. 그러려면 연속해서 먹는 접시 수가 몇 개를 먹어라에 해당한다.

 

첫 접근은 문제의 회전초밥 그림처럼 원순열에서 연속되게 k개를 뽑는 순열의 수를 생각했는데 어떻게 풀어야 하는지 도무지 감이 안왔다.

 

아이디어만 접근하고자 검색을 했더니

‘**투포인터**’, ‘**슬라이딩 윈도우**’가 나왔다.

초밥을 1차원 배열로 입력받고 **k 사이즈의 윈도우를 만들고** 한 칸씩 이동해보면서 그 때 마다의 가짓수를 생각해보면 되지 않을까?

 

가장 싸게 먹으면서 가장 많은 종류를 먹는 방법은 무엇일지 다시 생각해 보면 이런 것 같다.



1. 일단 쿠폰이 초밥 한 개를 무료로 제공하고 연속적으로 먹어야 한다고 문제에서 말하지 않았으니 쿠폰은 k개와 항상 연속적일 필요가 없다. 떨어져서 골라도 된다

2. 그렇다면 k개에 쿠폰 종류의 초밥을 제외하고 그 k개가 각 각 서로 다른 종류의 초밥일 때가 가장 많은 가짓수의 초밥이다.



풀이 및 구현

입력부를 제외한 처음의 풀이는 아래와 같았다.

`while(left < N) {	// left 커서가 belt 배열의 끝을 넘으면 모두 탐색한 것이다.

​	int cnt=0;

​	// 연속 k개 체크, 우측이 배열의 범위를 벗어날 수 있으므로 모드연산

​	for(int i=left; i<=right; i++) {

​		if(kind[belt[i%N]] != true) {

​			kind[belt[i%N]] = true;

​			cnt++;

​		}

​	}

​	// 쿠폰 체크

​	if(kind[c] != true) cnt++;

​	

​	if(max<cnt) max = cnt; // 다 센 초밥의 가짓수가 지금까지의 최대 가짓수보다 많으면 갱신

​	

​	// belt 배열 초기화

​	Arrays.fill(kind, false);

​	

​	// 윈도우 이동

​	left++;

​	right++;

}`

이렇게 하니 투포인터의 느낌은 들지만 정작 매번 중복연산이 발생하였다. 투포인터의 연산이 아닌 것이었다.

투포인터를 올바르게 사용하기 위해선 포인터를 이동시킬 기준이 필요하다. 이 문제에서 그 기준은 초밥의 가짓수이다

때문에 기준을 먼저 구하고 투포인터 연산을 해야한다. 나는 기준을 구하지 않고 투포인터 연산을 진행하였다.

이런 문제점을 확인하고 푼 풀이는 아래와 같다

`int ans = 0;

​		for(int i=0; i<k; i++) {

​			if(kind[belt[i]]==0) {

​				ans++;

​			}

​			kind[belt[i]]++; 	// 이 문장이 위 if문에 들어가선 안된다. 초밥이 한 번 세어지면 중복해서 셀 수가 없다.

​		}

​		System.***out\***.println(Arrays.*toString*(kind));

​		int cnt = ans; // 초밥 가짓수

​		for(int i=0; i<N; i++) {

​			if(cnt>=ans) {

​				if(kind[c]==0) ans = cnt+1;	//	++cnt, cnt++로 cnt를 증가시키려 하지마라 cnt가 변한다!

​				else ans = cnt;

​			}

​			kind[belt[i]]--;

​			if(kind[belt[i]]==0) cnt--;

​			if(kind[belt[(i+k)%N]]==0) cnt++;

​			kind[belt[(i+k)%N]]++;

​		}`