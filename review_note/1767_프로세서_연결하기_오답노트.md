# BOJ 1767 프로세서 연결하기 

-> 병국님은 같은 소스를 봤지만 디버깅을 성공함

이 문제는 일단 감을 잡지 못했다.

빡 구현 문제의 경우 어떤 식으로 상황을 처리해야할지 감이 잡히지 않는다.

어떤 식으로 상황을 처리한다 함은

### 1.   경우의 수를 모르겠다.

### 2.   경우의 수를 알아도 코드 상에서 어떤 식으로 조건 처리를 해야할 지 모르겠다

### 3.   여러 상황을 단계별로 처리해야 하는 경우 어떤 순서로 처리해야 옳은 답이 나올지 감이 잡히지 않는다.

### 4.   손으로 상황을 그려보려 하는데 단계별로의 표현이 어렵다

 

이 문제의 경우 최대한 많은 코어에 전원을 연결해야 한다고 하며 풀이로 먼저 <u>조합</u>을 접근함

 M개 중 M개를 뽑는 조합부터 시작해 0개를 뽑는 조합까지 생각해 주어야 한다고 함

#### **왜 조합일까?**

<u>M개 중 N개가 전원이 연결된다면 코어가 어느 순서로 뽑혔든지 상관없이 연결만 되면 되기에 뽑은 N개를 개별적이고 독립적인 것으로 보는 것이 아니라. 구별이 안되는 동일한 것으로 볼 수 있어서 조합을 쓴 것 같다.</u>

### 조합을 구하면 해야할 것

N개중 N개, N개중 N-1개, … 식으로 반복

 

전선의 길이의 합을 최소로 하는 경우를 생각해 보아야 함. <u>**전선의 길이를 최소로 만들려면**</u>

1. ### 일단 코어와 연결된 전선이 전원까지 연결이 되어야 길이의 합에 포함할 전선이 된다

2. ### 하나의 전선이 전원까지 연결되는지를 확인을 하고 다음 전선을 확인하러 가야한다.(DFS)

BFS적인 접근을 하면 내 전선 한 칸 확인 후 연장, 다음 전선 한 칸 확인 후 연장할 경우…는 가능한지는 생각해봐야 (BFS로 풀려면 어떻게?? 풀이는 **<u>앞선 DFS의 접근으로 풀음</u>**)

 

3. ### 정해코드에서는 코어 한 개에 대해 4방향 중 어느 한 방향으로라도 전원까지 갈 수 있는지 확인함. 

#### 		A.   구현팁 : for – while 문을 통해 한 방향으로 쭉 더함

#### 		B.   점묘법처럼 생각하기!

#####               i.     해당 상황에 가능한 경우

​					1.   새로 확인하려는 장소가 전원이다 -> 해당 코어는 성공적으로 전선 연결

​					2.   새로 확인하려는 장소가 빈칸이다 -> 전선연결해보기

​					3.   새로 확인하려는 장소가 전선(장애물)이다. -> 해당 코어의 현재 진행방향의 탐색은 중단하고 다음 방향 탐색하기 => 4							방 탐색 for문에 의해 새로운 방향으로 진행

#### 		C.   코어의 한 방향에 대해 탐색이 성공적이면 N개중 N-1개 뽑은 조합이고 방금 확인한 것이 0 번째 코어라면 1				번째 코어를 확인해 봐야함

#####               i.     Dfs( idx, cnt) -> Dfs( idx + 1, cnt + score) 코드는 이런데 idx + 1 이 다음 코어에 해당

#####               ii.     두 번째 인자인 cnt+score는 점수를 현재까지 연결한 전선 길이를 들고다니는 것

#### 		D.   If dfs() 다음의 while 다음 문장은 무슨 의미?

#####               i.     While문 안을 보면 x -= dx[i]; y -= dy[i]를 하고 있다. <u>왜 i 일까?</u> 앞선 if 문에서 <u>dfs를 호출이 최종적으로 끝</u>					<u>나는 경우</u>는 <u>시작 코어에서 처음 지정한 방향을 마지막 코어</u>까지 반복한 <u>딱 1가지 경우를 센 것</u>이다. 그 말인 즉슨 다른 					경우를 세보기 위해 여짓껏 조작한 map을 <u>초기 상태</u>로 원복을 시켜 놔야 다음 경우를 셀 수 있는 것이다.

